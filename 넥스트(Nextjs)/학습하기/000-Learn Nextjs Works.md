# 학습하기

## Next.js 작동 방식

고급 Next.js 기능을 배우기 전에 Next.js 작동 방식의 기본을 이해하는 것이 도움이 될 것입니다.

이 강좌의 시작 부분에서 React는 애플리케이션을 빌드하고 구조화하는 방법에 대해 비교적 자유로운 편이며, React로 애플리케이션을 빌드하는 방법에는 여러 가지가 있다고 이야기했습니다. Next.js는 애플리케이션을 구조화하는 프레임워크와 개발 과정과 최종 애플리케이션을 더 빠르게 만드는 데 도움이 되는 최적화를 제공합니다.

다음 섹션에서는 이러한 여러 단계에서 애플리케이션 코드에 어떤 일이 발생하는지 살펴보겠습니다.

- 코드가 실행되는 환경: 개발 환경과 프로덕션 환경
- 코드가 실행되는 시기: 빌드 시간 대 런타임
- 렌더링이 발생하는 위치: 클라이언트 대 서버

이제 이러한 개념에 대해 자세히 알아보고 Next.js가 백그라운드에서 수행하는 몇 가지 프로세스에 대해 논의해 보겠습니다.

## 개발에서 프로덕션까지

> **Development and Production Environments**
> 

환경은 코드가 실행되는 컨텍스트라고 생각하면 됩니다.

개발 중에는 로컬 컴퓨터에서 애플리케이션을 빌드하고 실행합니다. 프로덕션 환경으로 이동하는 것은 사용자가 애플리케이션을 배포하고 사용할 수 있도록 준비하는 과정입니다.

### Next.js 적용 방식

Next.js는 개발 및 포로덕션단계의 기능을 모두 제공합니다. 예를 들어

- 개발 단계에서 Next.js는 개발자와 개발자의 **애플리케이션 구축 경험에 맞게 최적화**됩니다. 내장된 TypeScript 및 ESLint 통합, 빠른 새로 고침 등 개발자 경험을 개선하기 위한 기능이 포함되어 있습니다.

프로덕션 단계에서 Next.js는 최종 사용자와 그들의 **애플리케이션 사용 경험**에 맞게 최적화합니다. 코드를 변환하여 **성능과 접근성을 높이는 것**을 목표로 합니다.

환경마다 고려해야 할 사항과 목표가 다르기 때문에 애플리케이션을 개발에서 프로덕션으로 이동하려면 수행해야 할 작업이 많습니다. 예를 들어 애플리케이션 코드를 컴파일하고, 번들로 묶고, 축소하고, 코드를 분할해야 합니다.

### Next.js 컴파일러

Next.js는 이러한 **코드 변환**과 기본 인프라의 대부분을 처리하여 애플리케이션이 프로덕션 환경으로 쉽게 이동할 수 있도록 지원합니다.

이는 Next.js에 로우레벨 프로그래밍 언어인 Rust로 작성된 컴파일러와 컴파일, 축소, 번들링 등에 사용할 수 있는 플랫폼인 SWC가 있기 때문에 가능한 일입니다.

## 컴파일

### 컴파일은 왜 할까?

개발자는 JSX, 타입스크립트, 최신 버전의 자바스크립트 등 개발자에게 더 친숙한 언어로 코드를 작성합니다. 이러한 언어는 개발자의 효율성과 자신감을 높여주지만 브라우저가 이를 이해하기 위해서는 자바스크립트로 컴파일해야 합니다.

컴파일은 한 언어로 된 코드를 다른 언어 또는 해당 언어의 다른 버전으로 출력하는 프로세스를 말합니다.

![Untitled](%E1%84%92%E1%85%A1%E1%86%A8%E1%84%89%E1%85%B3%E1%86%B8%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%2097881c3148db455f89e80b1b21af1761/Untitled.png)

Next.js에서 **컴파일은 코드를 편집하는 개발 단계**와 **애플리케이션을 프로덕션에 사용할 수 있도록 준비하는 빌드 단계의 일부**로 이루어집니다.

## 축소

### 축소란 무엇인가요?

개발자는 사람의 가독성을 위해 최적화된 코드를 작성합니다. 이 코드에는 주석, 공백, 들여쓰기, 여러 줄 등 코드 실행에 필요하지 않은 추가 정보가 포함될 수 있습니다.

![Untitled](%E1%84%92%E1%85%A1%E1%86%A8%E1%84%89%E1%85%B3%E1%86%B8%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%2097881c3148db455f89e80b1b21af1761/Untitled%201.png)

축소란 코드의 기능을 변경하지 않고 불필요한 코드 서식과 주석을 제거하는 프로세스입니다. 파일 크기를 줄여 애플리케이션의 성능을 개선하는 것이 목표입니다.

Next.js에서는 프로덕션을 위해 JavaScript 및 CSS 파일이 자동으로 축소됩니다.

## 번들링

### 번들링이 무엇인가요?

개발자는 애플리케이션을 모듈, 컴포넌트, 함수로 나누어 더 큰 규모의 애플리케이션을 구축할 수 있습니다. 이러한 내부 모듈과 외부 타사 패키지를 내보내고 가져오면 복잡한 파일 종속성 웹이 만들어집니다.

![Untitled](%E1%84%92%E1%85%A1%E1%86%A8%E1%84%89%E1%85%B3%E1%86%B8%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%2097881c3148db455f89e80b1b21af1761/Untitled%202.png)

번들링은 사용자가 웹 페이지를 방문할 때 파일 요청 횟수를 줄이기 위해 종속성 웹을 해결하고 파일(또는 모듈)을 브라우저에 최적화된 번들로 병합(또는 '패키지화')하는 프로세스입니다.

## 코드 분할

## 코드 분할이 무엇인가요?

개발자는 일반적으로 애플리케이션을 여러 페이지로 분할하여 서로 다른 URL에서 액세스할 수 있도록 합니다. 이러한 각 페이지는 애플리케이션의 **고유한 진입점**이 됩니다.

코드 분할은 애플리케이션의 번들을 각 진입점에 필요한 작은 청크로 분할하는 프로세스입니다. 목표는 해당 페이지를 실행하는 데 필요한 코드만 로드하여 애플리케이션의 초기 로드 시간을 개선하는 것입니다.

![Untitled](%E1%84%92%E1%85%A1%E1%86%A8%E1%84%89%E1%85%B3%E1%86%B8%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%2097881c3148db455f89e80b1b21af1761/Untitled%203.png)

Next.js는 코드 분할을 기본적으로 지원합니다. `pages/` `directory` 내의 각 파일은 빌드 단계에서 자체 JavaScript 번들로 자동 코드 분할됩니다.

### 추가

- 페이지 간에 공유되는 모든 코드도 다른 번들로 분할되어 추가 탐색 시 동일한 코드를 다시 다운로드하지 않도록 합니다.
- 초기 페이지 로드 후 Next.js는 사용자가 탐색할 가능성이 있는 다른 페이지의 코드를 미리 로드하기 시작할 수 있습니다.
- 동적 임포트는 처음 로드되는 코드를 수동으로 분할하는 또 다른 방법입니다.

## 빌드 시간 및 런타임

빌드 시간(또는 **빌드** 단계)은 프로덕션을 위해 애플리케이션 코드를 준비하는 일련의 단계에 지정된 이름입니다

애플리케이션을 빌드할 때 Next.js는 코드를 서버에 배포하고 사용자가 사용할 수 있는 프로덕션에 최적화된 파일로 변환합니다. 이러한 파일은 다음과 같습니다.

이러한 파일은 다음과 같습니다.

- 정적으로 생성된 페이지에 대한 HTML 파일
- 서버에서 페이지를 렌더링하기 위한 JavaScript 코드
- 클라이언트에서 대화형으로 페이지를 만들기 위한 JavaScript 코드
- CSS 파일

**런타임**(또는 요청 시간)은 응용 프로그램이 빌드 및 배포된 *후* 사용자의 요청에 대한 응답으로 응용 프로그램이 실행되는 기간을 나타냅니다.

## 클라이언트 및 서버

웹 응용 프로그램의 컨텍스트에서 **클라이언트는** 응용 프로그램 코드에 대한 요청을 서버에 보내는 사용자 장치의 브라우저를 나타냅니다. 그런 다음 서버로부터 받은 응답을 사용자가 상호 작용할 수 있는 인터페이스로 바꿉니다.

![Untitled](%E1%84%92%E1%85%A1%E1%86%A8%E1%84%89%E1%85%B3%E1%86%B8%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%2097881c3148db455f89e80b1b21af1761/Untitled%204.png)

**서버는** 애플리케이션 코드를 저장하고, 클라이언트로부터 요청을 수신하고, 일부 계산을 수행하고, 적절한 응답을 다시 보내는 데이터 센터의 컴퓨터를 말합니다.

## 렌더링

React에서 작성한 코드를 UI의 HTML 표현으로 변환하는 불가피한 작업 단위가 있습니다. 이 프로세스를 **렌더링**이라고 합니다.

렌더링은 서버 또는 클라이언트에서 수행할 수 있습니다. 빌드 시 미리 발생하거나 런타임에 모든 요청에서 발생할 수 있습니다.

Next.js에서는 서버 쪽 렌더링, **정적 사이트 생성** 및 **클라이언트 쪽** 렌더링의 세 가지 **렌더링** 방법을 사용할 수 있습니다.

### 사전 렌더링

서버 사이드 렌더링 및 정적 사이트 생성은 결과가 클라이언트로 전송되기 전에 외부 데이터를 가져오고 React 구성 요소를 HTML로 변환하기 때문에 **사전 렌더링**이라고도 합니다.

### **클라이언트 측 렌더링 vs. 사전 렌더링**

표준 React 애플리케이션에서 브라우저는 UI를 구성하기 위한 JavaScript 지침과 함께 서버에서 빈 HTML 셸을 받습니다. 이를 **클라이언트 쪽** 렌더링이라고 하는데, 초기 렌더링 작업이 사용자의 장치에서 발생하기 때문입니다

![Untitled](%E1%84%92%E1%85%A1%E1%86%A8%E1%84%89%E1%85%B3%E1%86%B8%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%2097881c3148db455f89e80b1b21af1761/Untitled%205.png)

> **메모:** React 또는 `useSWR`, `useEffect()`과 같은 데이터 가져오기 후크를 사용하여 데이터를 가져오도록 선택하여 Next.js 애플리케이션의 특정 구성 요소에 대해 클라이언트 측 렌더링을 사용하도록 선택할 수 있습니다.
> 

반면, Next.js는 기본적으로 모든 페이지를 **미리 렌더링합니다**. 사전 렌더링은 HTML이 사용자 장치의 JavaScript로 모든 작업을 수행하는 대신 서버에서 미리 생성됨을 의미합니다.

실제로 이는 완전히 클라이언트 쪽에서 렌더링된 앱의 경우 렌더링 작업이 수행되는 동안 사용자에게 빈 페이지가 표시됨을 의미합니다.

아래 그림은 사용자가 생성된 HTML을 볼 수 있는 미리 렌더링된 앱과 비교한 그림입니다.

![Untitled](%E1%84%92%E1%85%A1%E1%86%A8%E1%84%89%E1%85%B3%E1%86%B8%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%2097881c3148db455f89e80b1b21af1761/Untitled%206.png)

### 서버 사이드 렌더링

서버 사이드 렌더링을 사용하면 **각** 요청에 대해 페이지에서 페이지의 HTML이 서버에 생성됩니다. 그런 다음 페이지를 대화형으로 만들기 위해 생성된 HTML, JSON 데이터 및 JavaScript 지침이 클라이언트로 전송됩니다.

클라이언트에서 HTML은 빠른 비대화형 페이지를 표시하는 데 사용되는 반면, React는 JSON 데이터 및 JavaScript 명령을 사용하여 구성 요소를 대화형으로 만듭니다(예: 버튼에 이벤트 핸들러 연결). 이 과정을 **수화**라고 합니다.

Next.js에서 `getServerSideProps`를 사용하여 서버 사이드 렌더링 페이지를 선택할 수 있습니다.

> 메모: React 18 및 Next 12는 React 서버 구성 요소의 알파 버전을 도입합니다. 서버 구성 요소는 서버에서 완전히 렌더링되며 렌더링하는 데 클라이언트 쪽 JavaScript가 필요하지 않습니다. 또한 서버 구성 요소를 사용하면 개발자가 서버에 일부 논리를 유지하고 해당 논리의 결과만 클라이언트로 보낼 수 있습니다. 이렇게 하면 클라이언트로 전송되는 번들 크기가 줄어들고 클라이언트 측 렌더링 성능이 향상됩니다.
> 

### 정적 사이트 생성

정적 사이트 생성을 사용하면 HTML이 서버에서 생성되지만 서버 사이드 렌더링과 달리 런타임에 서버가 없습니다. 대신 응용 프로그램이 배포될 때 빌드 시 콘텐츠가 한 번 생성되고 HTML이 CDN에 저장되고 각 요청에 다시 사용됩니다.

Next.js에서 `getStaticProps`를 사용하여 페이지를 정적으로 생성하도록 선택할 수 있습니다.

> **메모:** `Incremental Static Regeneration`을 사용하여 사이트를 구축한 *후* 정적 페이지를 만들거나 업데이트할 수 있습니다. 즉, 데이터가 변경되더라도 전체 사이트를 다시 빌드할 필요가 없습니다.
> 

Next.js의 장점은 정적 사이트 생성, 서버 측 렌더링 또는 클라이언트 측 렌더링 등 사용 사례에 가장 적합한 렌더링 방법을 페이지별로 선택할 수 있다는 것입니다. 

## CDN과 Edge

### 네트워크란 무엇입니까?

애플리케이션 코드가 저장되고 네트워크에 배포된 후 실행되는 위치를 아는 것이 도움이 됩니다.

네트워크는 리소스를 공유할 수 있는 연결된 컴퓨터(또는 서버)로 생각할 수 있습니다.

Next.js 애플리케이션의 경우 애플리케이션 코드를 **원본 서버**, **CDN(콘텐츠 전송 네트워크)** 및 **Edge에** 배포할 수 있습니다. 이들 각각이 무엇인지 살펴 보겠습니다.

### 원본 서버

앞에서 설명했듯이 서버는 응용 프로그램 코드의 원래 버전을 저장하고 실행하는 주 컴퓨터를 나타냅니다.

이 서버를 **CDN 서버** 및 **Edge 서버와** 같이 애플리케이션 코드를 배포할 수 있는 다른 장소와 구분하기 위해 **원본**이라는 용어를 사용합니다.

오리진 서버가 요청을 받으면 응답을 보내기 전에 몇 가지 계산을 수행합니다. 이 계산 작업의 결과는 CDN(Content Delivery Network)으로 이동할 수 있습니다.

### 콘텐츠 전송 네트워크

CDN은 정적 콘텐츠(예: HTML 및 이미지 파일)를 전 세계 여러 위치에 저장하며 클라이언트와 원본 서버 사이에 배치됩니다. 새 요청이 들어오면 사용자에게 가장 가까운 CDN 위치에서 캐시된 결과로 응답할 수 있습니다.

![Untitled](%E1%84%92%E1%85%A1%E1%86%A8%E1%84%89%E1%85%B3%E1%86%B8%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%2097881c3148db455f89e80b1b21af1761/Untitled%207.png)

이렇게 하면 각 요청에서 계산이 수행될 필요가 없기 때문에 원본에 대한 부하가 줄어듭니다. 또한 응답이 지리적으로 더 가까운 위치에서 오기 때문에 사용자에게 더 빠릅니다.

Next.js에서는 사전 렌더링을 미리 수행할 수 있기 때문에 CDN은 작업의 정적 결과를 저장하는 데 적합하여 콘텐츠 전달 속도가 빨라집니다.

### 엣지

Edge는 사용자에게 가장 가까운 네트워크의 주변부(또는 edge)에 대한 일반화된 개념입니다. CDN은 네트워크의 가장자리에 정적 콘텐츠를 저장하기 때문에 **edge**의 일부로 간주될 수 있습니다.

CDN과 마찬가지로 에지 서버는 전 세계 여러 위치에 분산되어 있습니다. 그러나 정적 콘텐츠를 저장하는 CDN과 달리 일부 에지 서버는 작은 코드 조각을 실행할 수 있습니다.

즉, **캐싱**과 **코드 실행을** 모두 사용자에게 더 가까운 Edge에서 수행할 수 있습니다.

기존에 클라이언트 측 또는 서버 측에서 수행되던 일부 작업을 Edge로 이동하면 클라이언트로 전송되는 코드의 양이 줄어들고 사용자 요청의 일부가 원본 서버로 다시 돌아갈 필요가 없으므로 지연 시간이 줄어들기 때문에 애플리케이션의 성능을 높일 수 있습니다. 여기에서 Next.js가 포함된 Edge 예제를 참조하세요.

Next.js에서는 미들웨어를 사용하여 Edge에서 코드를 실행할 수 있으며 곧 React Server 구성 요소를 사용하여 코드를 실행할 수 있습니다.