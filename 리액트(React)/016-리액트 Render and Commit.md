# Render and Commit

> 렌더링 하고 커밋하기 

## 배울 내용들

1. React에서 렌더링 의미
2. React가 컴포넌트를 언제, 왜 렌더링 하는지
3. 화면에 컴포넌트를 표시하는 단계
4. 렌더링이 항상 DOM 업데이트를 하지 않는 이유

UI를 요청 하고 제공하는 세가지 단계

1. 렌더링 촉발
2. 컴포넌트 렌더링
3. DOM에 커밋

![Untitled](Render%20and%20Commit%209fc0d1dfa89a497aaa6d0d454519bfc0/Untitled.png)

## 스탭1: 렌더링을 촉발

컴포넌트가 렌더링이 일어나는 두가지 이유

1. 컴포넌트가 첫 렌더링 경우
2. 컴포넌트의 state(또는 상위요소 중 하나)가 업데이트 되는 경우

### 첫 렌더링

앱을 시작하기 위해서 첫 렌더링을 촉발시켜야 함. 대상 DOM 노드로 `createRoot` 를 호출한 다음 컴포넌트로 render 메서드를 호출하면 촉발됨.

### state가 업데이트되면 리렌더링

컴포넌트의 state를 업데이트하면 자동으로 렌더링 대기열에 추가.

![Untitled](Render%20and%20Commit%209fc0d1dfa89a497aaa6d0d454519bfc0/Untitled%201.png)

## 스탭2: React가 컴포넌트를 렌더링.

**렌더링은 React에서 컴포넌트를 호출하는 것**

- 첫 렌더링에서 React 루트 컴포넌트를 호출
- 이후 렌더링에서 React는 state 업데이트에 의해 렌더링이 발동된 함수 컴포넌트 호출
- 해당 과정은 재귀적. 중첩된 컴포넌트가 더 이상 없고 React가 화면에 표시되어야하는 내용을 정확히 알 때까지 이 단계는 계속됨.

### 주의할 점

렌더링은 한상 순수한 계산이어야 함

- **동일한 입력에 동일한 출력**
- **이전의 state를 변경해서는 안됨.**  렌더링 전에 존재했던 객체, 변수를 변경해서는 안됨.

그러지 않으면 코드 베이스가 복잠해짐에 따라 버그와 예측 불가능인 동작이 발생할 수 있음.

### 성능 최적화

업데이트 된 컴포넌트 내에 중첩된 모든 컴포넌트를 렌더링하는 기본 동작은 업데이트된 컴포넌트가 트리에서 매우 높은 곳에 있는 경우 성능 최적화가 되지 않습니다. 성능 문제가 발생하는 경우 [성능 섹션](https://legacy.reactjs.org/docs/optimizing-performance.html)에 설명된 몇 가지 옵트인 방식으로 문제를 해결 할 수 있으나 성급하게 최적화 하지 말 것.

## 스탭3: React가 DOM에 변경사항 커밋

컴포넌트를 렌더링한 후 React는 DOM을 수정

- **초기 렌더링 경우**
    - `appendChild()` DOM API를 사용하여 생성한 모든 DOM 노드를 화면에 표시
- **리렌더링 경우**
    - React에서 필요한 최소한의 작업(랜더링 동안 계산된 것)을 적용하여 DOM이 최신 렌더링 출력과 일치하도록 함.

렌더링 간에 차이가 있는 경우에만 DOM 노드를 변경

## 에필로그: 브라우저 페인트

렌더링 완료 후 React가 DOM에 업데이트한 후 브라우저는 화면을 다시 그림. 이 단계를 **브라우저 렌더링** 이라고 하지만 혼동을 피하기위해 나머지 부분에서 **페인팅** 이라고 부를 것임

⏮️ Previous: [State: A Component’s Memory](./015-리액트%20State%20A%20Component’s%20Memory.md)

⏭️ Next: [State as a Snapshot](./017-리액트%20State%20as%20a%20Snapshot.md)